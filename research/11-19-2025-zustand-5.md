# Zustand 5 Research

## Overview

- **Version**: 5.0.8 (Latest stable as of January 2025)
- **Purpose in Project**: Lightweight state management library for React applications
- **Official Documentation**: https://zustand.docs.pmnd.rs/
- **GitHub Repository**: https://github.com/pmndrs/zustand
- **NPM Package**: https://www.npmjs.com/package/zustand
- **Last Updated**: 2025-01-19

## Installation

```bash
npm install zustand
```

### Peer Dependencies

For specific use cases, you may need:

```bash
npm install use-sync-external-store
npm install @redux-devtools/extension
npm install immer
```

### Package Information

- **Dependencies**: 0 direct dependencies
- **Dependents**: 4,885+ projects in npm registry
- **Bundle Size**: Minimal (small and fast)
- **Description**: A small, fast and scalable bearbones state-management solution using simplified flux principles

## Core Concepts

### Basic Store Creation

Stores are created as hooks using the `create` function. State updates are immutable, with the `set` function handling merging automatically:

```javascript
import { create } from 'zustand';

const useBearStore = create((set) => ({
  bears: 0,
  increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
  removeAllBears: () => set({ bears: 0 }),
}));
```

### Component Integration

Components select and subscribe to state portions without requiring context providers:

```javascript
function BearCounter() {
  const bears = useBearStore((state) => state.bears);
  return <h1>{bears} around here...</h1>;
}

function Controls() {
  const increasePopulation = useBearStore((state) => state.increasePopulation);
  return <button onClick={increasePopulation}>one up</button>;
}
```

### State Selection Patterns

**Fetching All State** (triggers re-renders on any change):

```javascript
const state = useBearStore();
```

**Multiple State Slices** (atomic selections with strict equality):

```javascript
const nuts = useBearStore((state) => state.nuts);
const honey = useBearStore((state) => state.honey);
```

**Shallow Equality with useShallow**:

```javascript
import { useShallow } from 'zustand/react/shallow';

const { nuts, honey } = useBearStore(
  useShallow((state) => ({ nuts: state.nuts, honey: state.honey }))
);
```

**Custom Equality Functions**:

```javascript
const treats = useBearStore(
  (state) => state.treats,
  (oldTreats, newTreats) => compare(oldTreats, newTreats)
);
```

## Configuration

### State Overwriting

The `set` function's second argument enables replacement instead of merging:

```javascript
const useFishStore = create((set) => ({
  salmon: 1,
  tuna: 2,
  deleteEverything: () => set({}, true),
  deleteTuna: () => set(({ tuna, ...rest }) => rest, true),
}));
```

### Async Actions

Asynchronous operations call `set` when ready:

```javascript
const useFishStore = create((set) => ({
  fishies: {},
  fetch: async (pond) => {
    const response = await fetch(pond);
    set({ fishies: await response.json() });
  },
}));
```

### Reading State in Actions

Access current state via the `get` parameter:

```javascript
const useSoundStore = create((set, get) => ({
  sound: 'grunt',
  action: () => {
    const sound = get().sound;
  },
}));
```

## Usage Patterns

### Basic Usage

```javascript
import { create } from 'zustand';

const useCountStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
}));

function Counter() {
  const count = useCountStore((state) => state.count);
  const increment = useCountStore((state) => state.increment);

  return (
    <div>
      <p>{count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

### Advanced Patterns

**Exporting Only Custom Hooks** (recommended pattern):

```javascript
export const useBears = () => useBearStore((state) => state.bears);
export const useBearActions = () =>
  useBearStore((state) => ({
    increasePopulation: state.increasePopulation,
    removeAllBears: state.removeAllBears,
  }));
```

**Separating Actions from State**:

```javascript
const useBearStore = create((set) => ({
  bears: 0,
  fish: 0,
  actions: {
    increasePopulation: () => set((state) => ({ bears: state.bears + 1 })),
    eatFish: () => set((state) => ({ fish: state.fish - 1 })),
  },
}));

export const useBears = () => useBearStore((state) => state.bears);
export const useBearActions = () => useBearStore((state) => state.actions);
```

### Integration Examples

**Combining with React Query**:

```javascript
const useUserId = () => useUserStore((state) => state.userId);

function UserProfile() {
  const userId = useUserId();
  const { data } = useQuery(['user', userId], () => fetchUser(userId));

  return <div>{data?.name}</div>;
}
```

## Non-Reactive State Access

### Outside Components

```javascript
const useDogStore = create(() => ({ paw: true, snout: true, fur: true }));

const paw = useDogStore.getState().paw;

const unsub1 = useDogStore.subscribe(console.log);

useDogStore.setState({ paw: false });

unsub1();
```

### Subscribe with Selector

Using `subscribeWithSelector` middleware enables targeted subscriptions:

```javascript
import { subscribeWithSelector } from 'zustand/middleware';

const useDogStore = create(subscribeWithSelector(() => ({ paw: true, snout: true, fur: true })));

const unsub2 = useDogStore.subscribe((state) => state.paw, console.log);

const unsub3 = useDogStore.subscribe(
  (state) => state.paw,
  (paw, previousPaw) => console.log(paw, previousPaw)
);

const unsub4 = useDogStore.subscribe((state) => [state.paw, state.fur], console.log, {
  equalityFn: shallow,
});

const unsub5 = useDogStore.subscribe((state) => state.paw, console.log, {
  fireImmediately: true,
});
```

## Vanilla (Non-React) Usage

Core Zustand functions without React dependency:

```javascript
import { createStore } from 'zustand/vanilla';

const store = createStore((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));

const { getState, setState, subscribe, getInitialState } = store;
```

Using vanilla stores with React:

```javascript
import { useStore } from 'zustand';
import { vanillaStore } from './vanillaStore';

const useBoundStore = (selector) => useStore(vanillaStore, selector);
```

## Middleware

### Immer Integration

Simplifies nested state mutations:

```javascript
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

const useStore = create(
  immer((set) => ({
    nested: { object: { deep: true } },
    update: () =>
      set((state) => {
        state.nested.object.deep = false;
      }),
  }))
);
```

**With TypeScript**:

```typescript
import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

interface Todo {
  id: string;
  title: string;
  done: boolean;
}

type State = {
  todos: Record<string, Todo>;
};

type Actions = {
  toggleTodo: (todoId: string) => void;
};

export const useTodoStore = create<State & Actions>()(
  immer((set) => ({
    todos: {},
    toggleTodo: (todoId: string) =>
      set((state) => {
        state.todos[todoId].done = !state.todos[todoId].done;
      }),
  }))
);
```

### Persist Middleware

Automatically syncs state to storage:

```javascript
import { persist, createJSONStorage } from 'zustand/middleware';

const useStore = create(
  persist(
    (set) => ({
      fishes: 0,
      addAFish: () => set((state) => ({ fishes: state.fishes + 1 })),
    }),
    {
      name: 'food-storage',
      storage: createJSONStorage(() => sessionStorage),
    }
  )
);
```

### Redux DevTools

Enable time-travel debugging:

```javascript
import { devtools } from 'zustand/middleware';

const useStore = create(
  devtools((set) => ({
    count: 1,
    inc: () => set((state) => ({ count: state.count + 1 })),
  }))
);
```

**With Configuration**:

```javascript
const useStore = create(
  devtools(
    (set) => ({
      count: 1,
      inc: () => set((state) => ({ count: state.count + 1 })),
    }),
    {
      name: 'MyStore',
      enabled: process.env.NODE_ENV === 'development',
    }
  )
);
```

### Combining Multiple Middleware

The recommended order for wrapping middleware:

```typescript
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import type {} from '@redux-devtools/extension';

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<BearState>()(
  devtools(
    persist(
      immer((set) => ({
        bears: 0,
        increase: (by) =>
          set((state) => {
            state.bears += by;
          }),
      })),
      { name: 'bear-storage' }
    )
  )
);
```

## Slices Pattern

The slices pattern allows dividing large stores into smaller, modular pieces.

### Basic Implementation

**Fish Slice**:

```javascript
export const createFishSlice = (set) => ({
  fishes: 0,
  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),
});
```

**Bear Slice**:

```javascript
export const createBearSlice = (set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),
});
```

### Combining Slices

```javascript
import { create } from 'zustand';
import { createBearSlice } from './bearSlice';
import { createFishSlice } from './fishSlice';

export const useBoundStore = create((...a) => ({
  ...createBearSlice(...a),
  ...createFishSlice(...a),
}));
```

### Usage in Components

```javascript
function App() {
  const bears = useBoundStore((state) => state.bears);
  const fishes = useBoundStore((state) => state.fishes);
  const addBear = useBoundStore((state) => state.addBear);

  return (
    <div>
      <h2>Number of bears: {bears}</h2>
      <h2>Number of fishes: {fishes}</h2>
      <button onClick={() => addBear()}>Add a bear</button>
    </div>
  );
}
```

### Cross-Slice Actions

```javascript
export const createBearFishSlice = (set, get) => ({
  addBearAndFish: () => {
    get().addBear();
    get().addFish();
  },
});
```

### Middleware with Slices

Apply middlewares at the combined store level, not individual slices:

```javascript
import { persist } from 'zustand/middleware';

export const useBoundStore = create(
  persist(
    (...a) => ({
      ...createBearSlice(...a),
      ...createFishSlice(...a),
    }),
    { name: 'bound-store' }
  )
);
```

## TypeScript Usage

### Basic Pattern

```typescript
interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}));
```

### Using Combine Utility

The `combine` utility infers state automatically:

```typescript
import { create } from 'zustand';
import { combine } from 'zustand/middleware';

const useBearStore = create(
  combine({ bears: 0 }, (set) => ({
    increase: (by: number) => set((state) => ({ bears: state.bears + by })),
  }))
);
```

### Type Helper: ExtractState

```typescript
import { create, ExtractState } from 'zustand';
import { combine } from 'zustand/middleware';

const useBearStore = create(
  combine({ bears: 0 }, (set) => ({
    increase: (by: number) => set((state) => ({ bears: state.bears + by })),
  }))
);

type BearState = ExtractState<typeof useBearStore>;
```

## React Context Integration

Combine with Context for provider-based access:

```javascript
const StoreContext = React.createContext();

export const StoreProvider = ({ children }) => (
  <StoreContext.Provider value={useBearStore}>{children}</StoreContext.Provider>
);

export const useStore = () => useContext(StoreContext);
```

## Next.js Integration

### Key Challenges

1. **Per-request stores**: Store should be created per request rather than globally
2. **SSR compatibility**: Prevent hydration errors by matching initial states
3. **SPA routing support**: Client-side navigation requires store initialization via Context
4. **Server caching**: Module-based state works with Next.js's server-side caching

### Recommendations

- Avoid global stores that persist across requests
- React Server Components should not access the store
- Use `createStore` from 'zustand/vanilla' with a factory function

### Store Creation

```typescript
import { createStore } from 'zustand/vanilla';

export type CounterState = {
  count: number;
};

export type CounterActions = {
  decrementCount: () => void;
  incrementCount: () => void;
};

export type CounterStore = CounterState & CounterActions;

export const defaultInitState: CounterState = {
  count: 0,
};

export const createCounterStore = (initState: CounterState = defaultInitState) => {
  return createStore<CounterStore>()((set) => ({
    ...initState,
    decrementCount: () => set((state) => ({ count: state.count - 1 })),
    incrementCount: () => set((state) => ({ count: state.count + 1 })),
  }));
};
```

### Provider Setup

```typescript
'use client';

import { type ReactNode, createContext, useRef, useContext } from 'react';
import { useStore } from 'zustand';
import { type CounterStore, createCounterStore } from './store';

export type CounterStoreApi = ReturnType<typeof createCounterStore>;

export const CounterStoreContext = createContext<CounterStoreApi | undefined>(undefined);

export interface CounterStoreProviderProps {
  children: ReactNode;
}

export const CounterStoreProvider = ({ children }: CounterStoreProviderProps) => {
  const storeRef = useRef<CounterStoreApi>();
  if (!storeRef.current) {
    storeRef.current = createCounterStore();
  }

  return (
    <CounterStoreContext.Provider value={storeRef.current}>{children}</CounterStoreContext.Provider>
  );
};

export const useCounterStore = <T>(selector: (store: CounterStore) => T): T => {
  const counterStoreContext = useContext(CounterStoreContext);

  if (!counterStoreContext) {
    throw new Error(`useCounterStore must be used within CounterStoreProvider`);
  }

  return useStore(counterStoreContext, selector);
};
```

### Router-Specific Patterns

**Pages Router**: Wrap your `_app.tsx` component with the provider globally, or create stores per-route at the page level

**App Router**: Mark consumer components with `'use client'` and use the same provider pattern; wrap at layout or page level as needed

## Testing

### Jest Configuration

Create a mock file at `__mocks__/zustand.ts`:

```typescript
import { act } from '@testing-library/react';
import * as zustand from 'zustand';

const { create: actualCreate } = jest.requireActual<typeof zustand>('zustand');

export const storeResetFns = new Set<() => void>();

const createUncurried = <T>(stateCreator: zustand.StateCreator<T>) => {
  const store = actualCreate(stateCreator);
  const initialState = store.getState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const create = (<T>(stateCreator: zustand.StateCreator<T>) => {
  return typeof stateCreator === 'function' ? createUncurried(stateCreator) : createUncurried;
}) as typeof zustand.create;

afterEach(() => {
  act(() => {
    storeResetFns.forEach((resetFn) => {
      resetFn();
    });
  });
});
```

**Jest Config** (`jest.config.ts`):

```typescript
export default {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/setup-jest.ts'],
};
```

**Setup File** (`setup-jest.ts`):

```typescript
import '@testing-library/jest-dom';
```

### Vitest Configuration

Similar approach using `vi.importActual()`:

```typescript
import { vi } from 'vitest';
import * as zustand from 'zustand';

const { create: actualCreate } = await vi.importActual<typeof zustand>('zustand');
```

**Vitest Config**:

```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./setup-vitest.ts'],
  },
});
```

**Setup File** (`setup-vitest.ts`):

```typescript
import '@testing-library/jest-dom';

vi.mock('zustand');
```

### Testing Patterns

**Testing Components with Stores**:

```typescript
import { render, fireEvent } from '@testing-library/react';
import { useCountStore } from './store';

function Counter() {
  const count = useCountStore((state) => state.count);
  const increment = useCountStore((state) => state.increment);

  return (
    <div>
      <span>{count}</span>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

test('increments count', () => {
  const { getByText } = render(<Counter />);
  const button = getByText('Increment');

  expect(getByText('0')).toBeInTheDocument();
  fireEvent.click(button);
  expect(getByText('1')).toBeInTheDocument();
});
```

## Best Practices

### Code Organization

1. **Export Only Custom Hooks**: Prevents accidental subscriptions to entire store
2. **Use Atomic Selectors**: Return single values or primitives for better performance
3. **Separate Actions from State**: Actions never change, so they can be exposed via a single hook
4. **Model Actions as Events**: Store contains business logic; components trigger events

### Performance Optimization

1. **Be Specific with Selectors**: Select only what you need from the store
2. **Avoid Creating New Object References**: Creates unnecessary re-renders
3. **Use useShallow for Multiple Selections**: Prevents re-renders when selector output hasn't changed
4. **Subscribe to Specific State Slices**: Minimizes unnecessary re-renders

**Bad Practice**:

```javascript
const { setMessages } = useMessagesStore((state) => ({
  setMessages: state.setMessages,
}));
```

**Good Practice**:

```javascript
const setMessages = useMessagesStore((state) => state.setMessages);
```

### Store Architecture

1. **Keep Stores Small & Focused**: Each store handles one piece of state
2. **Use Multiple Stores**: Unlike Redux, Zustand encourages multiple specialized stores
3. **Use Slices for Related State**: If state is interrelated, use slices within a single store
4. **Separate Concerns**: Global client state in Zustand, server state in React Query/SWR

### State Management Separation

- **Global client state**: Zustand
- **Server state**: React Query or SWR (provides caching and performance optimizations)
- **UI state**: Component state or Zustand
- **Form state**: Dedicated form libraries or Zustand

## Common Gotchas

### Unstable Selector Outputs

Creating new references on every render causes infinite loops:

**Problem**:

```javascript
const [searchValue, setSearchValue] = useStore((state) => [
  state.searchValue,
  state.setSearchValue,
]);
```

**Solution**:

```javascript
const [searchValue, setSearchValue] = useStore(
  useShallow((state) => [state.searchValue, state.setSearchValue])
);
```

### Dynamically Created Functions

**Problem**:

```javascript
const action = useMainStore((state) => {
  return state.action ?? () => {}
})
```

**Solution**:

```javascript
const FALLBACK_ACTION = () => {};

const action = useMainStore((state) => {
  return state.action ?? FALLBACK_ACTION;
});
```

### Persist Middleware Initial State

In v5, persist middleware no longer stores the initial state during store creation. You must explicitly set state after creation if needed:

```javascript
const useCountStore = create(persist(() => ({ count: 0 }), { name: 'count' }));

useCountStore.setState({
  count: Math.floor(Math.random() * 1000),
});
```

## Anti-Patterns to Avoid

1. **Exporting Raw Store**: Leads to accidental subscriptions to entire store
2. **Returning Objects from Selectors**: Creates new references causing unnecessary re-renders
3. **Including Expensive Computations in Selectors**: Can degrade state update performance
4. **Using Global Stores in Next.js**: Causes data leaks between requests
5. **Accessing Store from React Server Components**: RSCs cannot use hooks or context
6. **Applying Middleware to Individual Slices**: Apply at combined store level only

## Error Handling

Zustand itself doesn't provide built-in error handling, but you can implement patterns:

```javascript
const useStore = create((set) => ({
  data: null,
  error: null,
  loading: false,

  fetchData: async () => {
    set({ loading: true, error: null });
    try {
      const response = await fetch('/api/data');
      const data = await response.json();
      set({ data, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },
}));
```

## Security Considerations

### localStorage and XSS

When using persist middleware with localStorage:

1. **XSS Vulnerabilities**: localStorage is accessible to any JavaScript running on the same origin
2. **Sensitive Data**: Never store authentication tokens, passwords, or sensitive data in localStorage
3. **Encryption**: Sensitive data should be encrypted before storage
4. **Alternative Storage**: Consider sessionStorage for more secure temporary storage

**Recommendations**:

- Use HTTPOnly and Secure cookies for session identifiers
- Store only non-sensitive data (user preferences, theme settings, UI state)
- Implement XSS prevention measures (Content Security Policy, input sanitization)
- Consider sessionStorage over localStorage for sensitive but non-persistent state

### Next.js Data Leaks

Using Zustand in server-side components can cause data to leak between requests. Always:

- Create stores per-request, not globally
- Use React Context for store distribution
- Keep stores in client components only

## Performance Tips

1. **Select Specific State**: Only subscribe to what you need
2. **Use useShallow**: For selecting multiple values as objects or arrays
3. **Memoize Computed Values**: Use selectors or custom hooks with useMemo
4. **Avoid Expensive Computations in Selectors**: Compute in actions or separate hooks
5. **Use Transient Updates**: Subscribe without triggering re-renders for performance-critical operations

**Transient Updates Example**:

```javascript
const useScratchStore = create((set) => ({ scratches: 0 }));

const Component = () => {
  const scratchRef = useRef(useScratchStore.getState().scratches);
  useEffect(() => useScratchStore.subscribe((state) => (scratchRef.current = state.scratches)), []);
};
```

## Version-Specific Notes

### Breaking Changes in v5

1. **React 18+ Required**: Dropped support for React versions below 18
2. **Custom Equality Functions**: `create` no longer accepts custom equality functions
3. **Stricter setState Types**: When `replace: true`, complete state object required
4. **Persist Middleware**: No longer stores initial state during store creation
5. **Default Exports Dropped**: Use named imports only
6. **TypeScript 4.5+ Required**: Minimum TypeScript version
7. **No UMD/SystemJS Support**: Modern module formats only
8. **No ES5 Support**: Modern JavaScript required

### Migration from v4

**Custom Equality Functions**:

Before (v4):

```javascript
import { create } from 'zustand'
import { shallow } from 'zustand/shallow'

const useStore = create((set) => ({...}))
const Component = () => {
  const { count, text } = useStore(
    (state) => ({ count: state.count, text: state.text }),
    shallow
  )
}
```

After (v5) - Option A:

```javascript
import { createWithEqualityFn as create } from 'zustand/traditional';
```

After (v5) - Option B:

```javascript
import { create } from 'zustand';
import { useShallow } from 'zustand/shallow';

const Component = () => {
  const { count, text } = useStore(
    useShallow((state) => ({ count: state.count, text: state.text }))
  );
};
```

**setState Replace Flag**:

v5 type signature:

```typescript
setState:
  (partial: T | Partial<T>, replace?: false) => void
  (state: T, replace: true) => void
```

Dynamic replace flag workaround:

```typescript
const replaceFlag = Math.random() > 0.5;
const args = [{ bears: 5 }, replaceFlag] as Parameters<typeof useBearStore.setState>;
store.setState(...args);
```

### What's New in v5

- **Native useSyncExternalStore**: Uses React 18's native hook instead of polyfill
- **Smaller Bundle Size**: Dropped `use-sync-external-store` package dependency
- **Modernized Codebase**: Removed legacy compatibility code
- **No New Features**: v5 focuses on maintenance and modernization

## Code Examples

### Complete Store with TypeScript

```typescript
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

interface Todo {
  id: string;
  text: string;
  completed: boolean;
}

interface TodoState {
  todos: Todo[];
  filter: 'all' | 'active' | 'completed';
}

interface TodoActions {
  addTodo: (text: string) => void;
  toggleTodo: (id: string) => void;
  removeTodo: (id: string) => void;
  setFilter: (filter: TodoState['filter']) => void;
}

type TodoStore = TodoState & TodoActions;

export const useTodoStore = create<TodoStore>()(
  devtools(
    persist(
      immer((set) => ({
        todos: [],
        filter: 'all',

        addTodo: (text) =>
          set((state) => {
            state.todos.push({
              id: Date.now().toString(),
              text,
              completed: false,
            });
          }),

        toggleTodo: (id) =>
          set((state) => {
            const todo = state.todos.find((t) => t.id === id);
            if (todo) {
              todo.completed = !todo.completed;
            }
          }),

        removeTodo: (id) =>
          set((state) => {
            state.todos = state.todos.filter((t) => t.id !== id);
          }),

        setFilter: (filter) => set({ filter }),
      })),
      { name: 'todo-storage' }
    )
  )
);

export const useTodos = () =>
  useTodoStore((state) => {
    const { todos, filter } = state;
    return filter === 'all'
      ? todos
      : filter === 'active'
      ? todos.filter((t) => !t.completed)
      : todos.filter((t) => t.completed);
  });

export const useTodoActions = () =>
  useTodoStore((state) => ({
    addTodo: state.addTodo,
    toggleTodo: state.toggleTodo,
    removeTodo: state.removeTodo,
    setFilter: state.setFilter,
  }));
```

### Computed Values Pattern

```typescript
import { create } from 'zustand';

interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
}

interface CartStore {
  items: CartItem[];
  addItem: (item: CartItem) => void;
  removeItem: (id: string) => void;
  updateQuantity: (id: string, quantity: number) => void;
}

export const useCartStore = create<CartStore>((set) => ({
  items: [],

  addItem: (item) =>
    set((state) => ({
      items: [...state.items, item],
    })),

  removeItem: (id) =>
    set((state) => ({
      items: state.items.filter((item) => item.id !== id),
    })),

  updateQuantity: (id, quantity) =>
    set((state) => ({
      items: state.items.map((item) => (item.id === id ? { ...item, quantity } : item)),
    })),
}));

export const useCartTotal = () =>
  useCartStore((state) =>
    state.items.reduce((total, item) => total + item.price * item.quantity, 0)
  );

export const useCartCount = () =>
  useCartStore((state) => state.items.reduce((count, item) => count + item.quantity, 0));
```

### Multiple Store Pattern

```typescript
import { create } from 'zustand';

export const useAuthStore = create<AuthStore>((set) => ({
  user: null,
  login: async (credentials) => {},
  logout: () => set({ user: null }),
}));

export const useUIStore = create<UIStore>((set) => ({
  theme: 'light',
  sidebar: false,
  toggleTheme: () =>
    set((state) => ({
      theme: state.theme === 'light' ? 'dark' : 'light',
    })),
  toggleSidebar: () => set((state) => ({ sidebar: !state.sidebar })),
}));

export const useDataStore = create<DataStore>((set) => ({
  data: [],
  loading: false,
  error: null,
  fetchData: async () => {},
}));
```

## References

- Official Documentation: https://zustand.docs.pmnd.rs/
- GitHub Repository: https://github.com/pmndrs/zustand
- NPM Package: https://www.npmjs.com/package/zustand
- Migration Guide v5: https://zustand.docs.pmnd.rs/migrations/migrating-to-v5
- Announcing Zustand v5: https://pmnd.rs/blog/announcing-zustand-v5
- Working with Zustand (Best Practices): https://tkdodo.eu/blog/working-with-zustand
- Redux DevTools Extension: https://github.com/reduxjs/redux-devtools
- React Testing Library: https://testing-library.com/docs/react-testing-library/intro/
